---
title: "UN_assembly_proj"
output: 
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true
    
---

```{r setup, include=FALSE}
# ignore the errors
knitr::opts_chunk$set(error = TRUE)

library(dplyr)
library(tidyverse)
```


# Dataset
## UNGA

```{r}
#UNGA dataset
assembly <- readr::read_csv("2024_09_12_ga_resolutions_voting.csv")
head(assembly)
```


```{r}
unique(assembly['ms_name'])
```

Country name descrepancies: Yogoslavia republik, USSR, Ukranian SSR, Belorussian SSR, Turkey and Turkiye, East and West Germany, Former Yugoslav Republic of Macedonia, Serbia and Montenegro, etc.


```{r}
str(assembly)
```

```{r}
unique(assembly['modality'])
```


GERGM: we can use weights and predict a continuous number (countries that voted together 4 times).

We chose years 2023 and 2024 for the Palestine Topic because of the events that happened in Gaza in October 2023.
```{r}
# working with the date variable
assembly <- assembly |> dplyr::mutate(date = lubridate::ymd(date))

data <- assembly %>% 
  dplyr::mutate(year = lubridate::year(date)) %>% #changing year variable
  filter(year %in% c(2023, 2024)) #including only 2023 and 2024
```


```{r}
#how many countries are in UN
unique(data['ms_code'])
```


```{r}
unique(data['title'])
```


```{r}
unique(data['subjects'])
```

**Related topics**: PALESTINE QUESTION, TERRITORIES OCCUPIED BY ISRAEL--SETTLEMENT POLICY, TERRITORIES OCCUPIED BY ISRAEL--HUMAN RIGHTS--REPORTS, TERRITORIES OCCUPIED BY ISRAEL--NATURAL RESOURCES, TERRITORIES OCCUPIED BY ISRAEL--HUMAN RIGHTS

```{r}
# include subject where words PALESTINE and ISRAEL are present
data <- data |> 
  filter(stringr::str_detect(subjects, "PALESTINE|ISRAEL"))
```



```{r}
#include only these variables
data <- data[c('ms_code', 'ms_vote', 'resolution', 
                                       'title')]
# deleting NV votes
data <- data |> 
  filter(ms_vote != "NV")
```
About 100 votes were NV


```{r}
#checking for duplicates
nrow(unique(data)) == nrow(data)
```


```{r}
#which resolutions are held
unique(data['title'])
```
Six resolutions overall that are about Palestine-Israel conflict.


## Democracy level

```{r}
# V-Dem project
democracy <- readr::read_csv("V-Dem-CY-Full+Others-v14.csv")
```

```{r}
democracy <- democracy |> 
  filter(year == 2023)

#leaving only needed columns
democracy <- democracy[c('country_text_id', 'v2x_polyarchy', 'v2x_libdem', 
                       'v2x_partipdem', 'v2x_delibdem', 'v2x_egaldem')]
```

**v2x_polyarchy** - To what extent is the ideal of electoral democracy in its fullest sense achieved?
**v2x_libdem** - To what extent is the ideal of liberal democracy achieved?
**v2x_partipdem** - To what extent is the ideal of participatory democracy achieved?
**v2x_delibdem** - To what extent is the ideal of deliberative democracy achieved?
**v2x_egaldem** - To what extent is the ideal of egalitarian democracy achieved? (rights are protected equally across all groups)

Many researchers use only first characterization:
```{r}
democracy <- democracy[c('country_text_id', 'v2x_polyarchy')]
```



# Edge is voting Yes together

```{r}
countries <- unique(data$ms_code)

n <- length(countries)
adj_matrix <- matrix(0, nrow = n, ncol = n, dimnames = list(countries, countries))

resolutions <- unique(data$resolution)
for (res in resolutions) {
  # Filter votes for the current resolution
  votes <- data |> filter(resolution == res)
  
  # Get pairs of countries that voted "Yes"
  yes_votes <- votes |> filter(ms_vote == "Y")
  yes_pairs <- combn(yes_votes$ms_code, 2, simplify = FALSE)
  
  # Increment matrix for "Yes" pairs
  for (pair in yes_pairs) {
    adj_matrix[pair[1], pair[2]] <- adj_matrix[pair[1], pair[2]] + 1
    adj_matrix[pair[2], pair[1]] <- adj_matrix[pair[2], pair[1]] + 1  # Symmetric
  }
}
```


```{r}
#making network
yes_graph <- igraph::graph_from_adjacency_matrix(adj_matrix, 
                                                   mode = "undirected", 
                                                   weighted = TRUE)
```


```{r}
print(yes_graph)
```


```{r}
plot(yes_graph, edge.width = igraph::E(yes_graph)$weight, 
     vertex.label = igraph::V(yes_graph)$name)
```

```{r}
snafun::is_connected(yes_network)
snafun::g_density(yes_network)
```




## Same method as B. Kim et al


```{r}
adj_matrix2 <- matrix(0, nrow = n, ncol = n, dimnames = list(countries, countries))

for (res in resolutions) {
  # Filter votes for the current resolution
  votes <- data |> filter(resolution == res)
  
  # Compare all pairs of countries
  for (i in 1:(nrow(votes) - 1)) {
    for (j in (i + 1):nrow(votes)) {
      country1 <- votes$ms_code[i]
      country2 <- votes$ms_code[j]
      vote1 <- votes$ms_vote[i]
      vote2 <- votes$ms_vote[j]
      
      # Calculate agreement score
      if (vote1 == vote2) {
        score <- 1  # Full agreement
      } else if ((vote1 == "Y" && vote2 == "A") || (vote1 == "A" && vote2 == "Y") ||
                 (vote1 == "N" && vote2 == "A") || (vote1 == "A" && vote2 == "N")) {
        score <- 0.5  # Partial agreement
      } else {
        score <- 0  # No agreement
      }
      
      # Update adjacency matrix
      adj_matrix2[country1, country2] <- adj_matrix2[country1, country2] + score
      adj_matrix2[country2, country1] <- adj_matrix2[country2, country1] + score  # Symmetric
    }
  }
}
```


```{r}
#round down for count ergm
adj_matrix3 <- floor(adj_matrix2)
```


```{r}
# democracy index covariate
countries <- rownames(adj_matrix)

node_df <- data.frame(country_text_id = countries)

# merging with democracy scores
node_df <- node_df |>
  left_join(democracy, by = "country_text_id")

# using mean scores to fill in missing values
node_df$v2x_polyarchy[is.na(node_df$v2x_polyarchy)] <- mean(node_df$v2x_polyarchy, na.rm = TRUE)
```


```{r}
#making network
agree_graph <- igraph::graph_from_adjacency_matrix(adj_matrix2,
                                                     mode = "undirected",
                                                     weighted = TRUE)
print(agree_graph)
```

```{r}
plot(agree_graph, 
     edge.width = igraph::E(agree_graph)$weight, 
     vertex.label = igraph::V(agree_graph)$name)
```

The edge is this network is the level of agreement on votes. Weight - sum of agreement scores.


```{r}
igraph::is_connected(agree_graph)
igraph::edge_density(agree_graph)
```



# GERGM

```{r}
#checking symmetry
all(adj_matrix2 == t(adj_matrix2))
#checking for NAs
any(is.na(adj_matrix2))
any(adj_matrix2 < 0) 
```

```{r}
all(rownames(adj_matrix) == covariate_data$country_text_id)
```


```{r}
model1 <- GERGM::gergm(adj_matrix ~ edges + triangles + nodecov("v2x_polyarchy"),
                       covariate_data = covariate_data,
                       number_of_networks_to_simulate = 1000, #this sample size for now
                       thin = 1/10,
                       proposal_variance = 0.05,
                       MCMC_burnin = 500,
                       seed = 456,
                       convergence_tolerance = 0.01,
                       cores = 3)
summary(model1)
```



## ERGM count

Edges represent counts.
Network object as a target value
```{r}
class(agree_graph)
```


```{r}
snafun::has_isolates(agree_graph)
snafun::is_connected(agree_graph)
```


```{r}
#network object
yes_net <- network::network(adj_matrix, directed = FALSE, matrix.type = "adjacency")
set.edge.attribute(yes_net, "weight", as.vector(adj_matrix[adj_matrix > 0]))
set.vertex.attribute(yes_net, "democracy_score", node_df$v2x_polyarchy)
```



```{r}
library(ergm)
library(ergm.count) # had to use library because of the configurations confusion

model2 <- ergm(yes_net ~ edges + nodecov("democracy_score"),
               response = "weight",      # the edge attribute
               reference = ~Poisson)     # Poisson distribution for counts

summary(model2)
```
Positive nodecov.sum.democracy_score means that countries with higher democracy scores are more likely to form connections.



```{r}
#network for agreement scores
agree_net <- network::network(adj_matrix3, directed = FALSE, matrix.type = "adjacency")
set.edge.attribute(agree_net, "weight", as.vector(adj_matrix[adj_matrix > 0]))
set.vertex.attribute(agree_net, "democracy_score", node_df$v2x_polyarchy)
```



```{r}
model2 <- ergm(agree_net ~ edges + nodecov("democracy_score"),
               response = "weight",      # the edge attribute
               reference = ~Poisson)     # Poisson distribution for counts

summary(model2)
```

